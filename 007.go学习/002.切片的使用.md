# 切片的使用

## 1. 为什么使用切片

1. 数组的容量时固定的，不能自动拓展
2. 值传递，数组作为函数参数时，将整个数组拷贝一份传递给形参
3. 在 Go 语言中，几乎所有的场景，都可以使用切片替换数组
4. 本质: 不是一个数组，是一种数据结构，用来操作数组内部元素。

```go
// runtime/slice.go

type slice struct {
	array unsafe.Pointer
	len   int // 长度
	cap   int // 容量
}

```

## 2. 切片使用

- 切片在作函数时是传引用(传地址)
- 数组和切片的区别
  - 创建数组时 [] 里指定必须长度
  - 创建切片时 [] 里为空或 ...
- slice1 := arr [ low : high : cap ], 从数组截取成切片, 从low开始到high, 不包括 high
  - low: 起始的下标位置
  - high: 结束下标位置(不包含 high位置数据)， len = high - low
  - cap: 容量
    - 切片容量可指定
    - 不指定时: cap = cap(arr) - low, 即: 元素组/切片的容量 - low
- 创建切片
  - 自动推导: slice ：= []int{1, 2, 3}
  - slice := make([]int, 长度， 容量)
  - slice := make([]int, 长度)， 创建时没有指定容量， 容量=长度（最常用的方式）
- 切片追加: s1 = append(s1, element)
  - 向切片增加元素时， 切片的容量不够时会自动增长(cap 小于 1024时: cap = cap * 2, 大于1024 时有新算法，只需要指导容量会自动增加即可), 因此，切片追加时，切片的地址可能变化
- 切片拷贝: i := copy(s1, s2)
  - 拷贝是将 s2 的切片从开始位置覆盖 s1 切片
  - 拷贝不会增加 s1 切片的长度，如果 len(s2) > len(s1), 那么只会将 s2 中前 len(s1) 个数据拷贝到 s1


## 3. 切片使用练习

- [002.01.slice-去除空字符串.go](./func/002.01.slice-去除空字符串.go)
- [002.02.slice-去除切片中重复的字符串.go](./func/002.02.slice-去除切片中重复的字符串.go)
- [002.03.slice-删除某个元素.go](./func/002.03.slice-删除某个元素.go)

